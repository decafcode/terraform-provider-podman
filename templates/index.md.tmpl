# Podman Provider

Deploy containers and associated configuration using Podman's native management API.

## Container Host URL

This provider interacts with a Podman API endpoint identified by a URL that adheres to the format described in [Podman's documentation](https://docs.podman.io/en/latest/markdown/podman.1.html#url-value), which can identify an API endpoint on a UNIX domain socket, an unencrypted TCP socket, or a UNIX domain socket on a remote host that is accessed over SSH. Most users will want to interact with a remote container host over SSH.

A default `container_host` value can be specified as an attribute of the provider (see schema below), or a `container_host` value can be specified as an attribute on any of the resource types implemented by this provider. This latter option is useful because it enables cloud compute instances running Podman to be created and then containers to be deployed from a single Terraform configuration by deriving a resource-level `container_host` from the attributes of the compute instance resources. The default provider-level `container_host` attribute, by contrast, cannot be derived from any resource-level attributes due to Terraform's present limitations.

If neither a resource-level nor provider-level `container_host` attribute is set then the container host URL will be taken from the `CONTAINER_HOST` environment variable. If this environment variable is also left unset then the provider will raise an error.

### SSH hosts

This provider uses Go's [crypto/ssh](https://pkg.go.dev/golang.org/x/crypto/ssh) package to communicate with hosts over SSH instead of using an external OpenSSH executable. This leads to several important differences in behavior.

The most important difference is that this provider does not use your `~/.ssh/known_hosts` file. Host public keys must instead be managed manually by adding fragment parameters to the end of the container host URL. An `ssh://` URL must end with one of the following fragments, which are listed in order of most to least secure, otherwise an error will be raised:

1. `#ca=` followed by an SSH key type and base64 public key, separated by a space, all of which should be URL-escaped. This will be treated as the public key of an SSH certificate authority, and the provider will raise an error unless the remote host presents a certificate that is signed by this certificate authority and that has the connection URL's hostname as its subject.
2. `#pubkey=` followed by an SSH key type and base64 public key, separated by a space, all of which should be URL-escaped. The provider will raise an error if the remote host's public key does not match.
3. `#trust_unknown_host=1` to blindly trust the remote host. This is very much not recommended, so you have to specify this parameter in order to disable authentication of the remote host.

If you are connecting to a manually deployed remote host with a known public key then you should incorporate its public key into the container host URL as described in point 2 above. As an alternative, a separate Terraform provider called [sshid](https://github.com/decafcode/terraform-provider-sshid) has been provided to make it easier to keep track of the host keys of compute instances that were created using infrastructure automation. Here is a quick example showing how that provider might be used in conjunction with this one:

```terraform
resource "sshid_host" "server" {
  host = digitalocean_droplet.server.ipv4_address
}

locals {
  container_host = "ssh://user@${digitalocean_droplet.server.ipv4_address}/run/podman/podman.sock#pubkey=${urlencode(sshid_host.server.public_key)}"
}
```

Note that the `sshid_host` resource will blindly trust the remote host on first use. This is probably safe, but if you want to take a more rigorous approach then you can instead use your cloud provider's key management service (if it has one, DigitalOcean as used in the example above currently doesn't) to build an SSH CA. The sshid provider linked above includes a utility function that can convert an X.509 format public key returned from a cloud provider's key management API into an SSH-compatible form that can be used in the `#ca=...` parameter described above. Please consult sshid's documentation for further details.

Aside from the manner in which host public keys are validated, the following differences are also present:

- A username must always be specified when using an `ssh://` URL, otherwise an error will be raised. There is no built-in default user name.
- Public key authentication to the remote host requires the use of an SSH agent.
- In general, the contents of `/etc/ssh/` and `~/.ssh/` have no effect on how this provider operates (except indirectly via its interaction with your SSH agent).

## Importing

The following resource types can be imported:

- `podman_container`
- `podman_network`
- `podman_secret`

The import ID passed to `terraform import` takes one of two forms: either the value of the resource's `id` attribute by itself, or the `id` followed by the `container_host` separated by a comma.

Podman resources are mostly immutable, and the API provides limited support for this provider to be able to inspect resource state on the container host and reconcile it against the expected Terraform state, so all in all the ability to import pre-existing Podman resources into Terraform is of limited use. Nonetheless, the functionality is there if you need it.

## Missing functionality

This provider currently lacks support for the following Podman features. Support may or may not be added at a later date. Patches welcome.

- Image building
- Pods
- Volumes (as a managed entity; host filesystem locations can be mounted into container filesystems as you'd expect)

## Example Usage

{{ tffile .ExampleFile }}

{{ .SchemaMarkdown }}
